/*F - фамилия преподавателя.
  HomeWork - хмм, может быть это означает домашнюю работу? Да не, бред какой-то (*и продолжаю кушать).  */

#include "pch.h"
#include <conio.h>
#include <iostream>
#include <vector>

using namespace std; 

vector < vector<int> > matrix; // Создаём двумерный вектор.

int counter = 0; // Счётчик главной диагонали. 

/*Исходя из условия задания необходимо найти точки сочлинения в заданном 
  с помощью матрицы смежности графе. Не трудно заметить, что если убрать одну из
  вершин, то не только графически граф разделится на две/три/четрые/etc. частей,
  но и в таблице смежности нельзя будет пройти от первой вершины до последней. Принцип
  работы алгоритма немного похож на обход в глубину, но не совсем. Допустим, есть матрица:
  0 1 0 1 1 0 0 0
  1 0 0 0 0 0 0 0
  0 0 0 1 0 0 0 0
  1 0 1 0 0 0 0 1
  1 0 0 0 0 1 0 0
  0 0 0 0 1 0 1 1
  0 0 0 0 0 1 0 1
  0 0 0 1 0 1 1 0
  Видно, что вершины 1 и 4 - точки сочленения. Принцип работы алгоритма: на вход функции поступает число -
  номер вершины, которую хотим проверить. Чтобы проверить, убираем её (просто не рассматриваем её стороку и столбец).
  0 0 0 0 0 0 0
  0 0 1 0 0 0 0
  0 1 0 0 0 0 1
  0 0 0 0 1 0 0
  0 0 0 1 0 1 1
  0 0 0 0 1 0 1
  0 0 1 0 1 1 0
  Начинаем обход с точки 2. Помечаем её, что уже прошли (помечаем по диагонали, т.е. matrix[1][1] (индексы идут с 0, а 
  номера вершин с 1, это нужно помнить)). Из вершины 2 никуда больше уйти нельзя => вершина 1 является точкой сочлинения. 
  Это самый элементарный пример. Алгоритм работает и на более сложных. 
  */

bool f(int n)
{
	counter = 0; // Каждый вход ставим значение счётчика на 0.
	matrix[0][0] = 2; // Алгоритм каждый раз начинает обход с первой вершины, поэтому ставим, что мы уже в ней...
	if (n == 0) matrix[1][1] = 2; // ...но если проверяем первую вершину, то начинаем со второй. Ставим, что мы зашли во вторую.
	for (int i = 0; i < matrix.size(); i++) // Начинаем с первого столбца и до тех пор, пока не придём к последней вершине.
	{
		if (matrix[i][i] == 2) // Метку, что в эту точку мы уже побывали. 
		{
			for (int q = 0; q < matrix.size(); q++) // Перебираем значения ниже, по столбцу.
			{

				/*Если встретим 1 - значит мы можем перейти из вершины с номером i в вершину с номером q. 
				  Закрашиваем точку с номеру q, т.к. мы туда в теории можем перейти, но пока что это не надо. Да
				  и потом уже не понадобится, ибо мы знаем, что туда можем перейти. Если окажется, что из вершины q больше никуда нельзя
				  будет перейти - то правильно сделали, что закрасили её. Если окажется, что можно, то не страшно, из других
				  вершин узнаем, куда она ведёт. 
				  Так же в условии указываем, что не нужно рассматривать строку и столбец под номером n, т.к. эту точку мы проверяем
				  (т.е. удалили из матрицы, якобы. Так сделано, чтобы не нужно было создавать новую дублирующую матрицу). */

				if (matrix[q][i] == 1 && i != n && q != n) 
				{
					
					matrix[q][q] = 2;
				}
			}
		}
	}

	/*Когда алгоритм прошёл все вершины (если смог пройти все), то смотрим главную диагональ, там мы отмечали, 
	  какие вершины прошли. Если по диагонали везде стоят 2-ки, значит удалось зайти во все вершины. Если 
	  хотя бы в одну вершину зайти не смогли (по диагонали стоит 0 в одном или более местах), то возвращаем true. */

	for (int i = 0; i < matrix.size(); i++)
	{
		if (matrix[i][i] == 2)
		{
			counter++;
			matrix[i][i] = 0;
		}
	}
	if (counter >= matrix.size() - 1) return false;
	else return true;
}

/*Основная функция. */

int main()
{
	setlocale(0, ""); // Подключает русскую локализацию.
	int a, b; // В переменную "а" вводятся части матрицы, а в "b" - количество вершин. 
	cout << "Укажите количество вершин: ";
	cin >> b;

	/*Заполняем двумерный вектор. Заполнять можно как и по одному числу, так и матрицей разом.
	  Например, если скопировать матрицу в таком виде, как эта и вставить в консоль, то программа 
	  всё равно будет работать.
	  0 1 1 0 0 0 0 0
	  1 0 1 0 0 0 0 0
	  1 1 0 1 0 0 1 0
	  0 0 1 0 1 1 0 0
	  0 0 0 1 0 0 0 0
	  0 0 0 1 0 0 1 0
	  0 0 1 0 0 1 0 1
	  0 0 0 0 0 0 1 0
	  Кстати, можно использовать как тест. 
	  */

	for (int i = 0; i < b; i++)
	{
		matrix.push_back(vector<int>());
		for (int q = 0; q < b; q++)
		{
			cin >> a;
			matrix[i].push_back(a);
		}
	}

	cout << "Точки сочленения: ";

	/*Создаём цикл for и вызываем булеву функцию, описанную выше, для каждой вершины. Если функция вернула 
	  true, значит данная вершина - точка сочленения. Если вернула false - вершина не является точкой сочлинения. */

	for (int i = 0; i < matrix.size(); i++)
	{
		if (f(i)) cout << i + 1 << " ";
	}

	cout << "\nНажмите любую клавишу для выхода. ";
	_getch();
}
